<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      cve-2020-8597 pppd stackoverflow | H4lo&#39;s blog 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="John Doe">
    
    

    <meta name="description" content="前言在 3月6号，国外安全研究员 Ilja Van Sprundel(IOActive) 发现了 pppd 组件的 EAP 协议中一个存在了 17 年的严重的栈溢出漏洞，导致所以使用 pppd 组件的系统都受影响，包括 Ubuntu、Debian、Fedora 等，有潜在的远程代码执行的风险，CVSS 评分为 9.8。 前置知识 EAP 协议概念：  &gt; EAP协议是使用可扩展的身份验证协议">
<meta property="og:type" content="article">
<meta property="og:title" content="cve-2020-8597 pppd stackoverflow | H4lo&#39;s blog">
<meta property="og:url" content="http://yoursite.com/2020/03/22/cve-2020-8597-pppd-stackoverflow/index.html">
<meta property="og:site_name" content="H4lo&#39;s blog">
<meta property="og:description" content="前言在 3月6号，国外安全研究员 Ilja Van Sprundel(IOActive) 发现了 pppd 组件的 EAP 协议中一个存在了 17 年的严重的栈溢出漏洞，导致所以使用 pppd 组件的系统都受影响，包括 Ubuntu、Debian、Fedora 等，有潜在的远程代码执行的风险，CVSS 评分为 9.8。 前置知识 EAP 协议概念：  &gt; EAP协议是使用可扩展的身份验证协议">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://static.zybuluo.com/H4l0/bmyrepdupfcuj9hhuer0ra0x/image.png">
<meta property="og:image" content="http://static.zybuluo.com/H4l0/j5xh9tkn0zkrr51dt9kwmnvk/image.png">
<meta property="og:image" content="http://static.zybuluo.com/H4l0/ff53jxokc4sf5l117fwrexx6/image.png">
<meta property="og:image" content="http://static.zybuluo.com/H4l0/hjtax41lrm7zi09rg6rqo3ij/image.png">
<meta property="og:image" content="http://static.zybuluo.com/H4l0/aswyzqnylf9oj341kkjs4i4h/image.png">
<meta property="og:image" content="http://static.zybuluo.com/H4l0/pgbm690ie2lq6sgerpi6x65y/image.png">
<meta property="og:image" content="http://static.zybuluo.com/H4l0/wu326u3885dromi3lyrmeym1/image.png">
<meta property="og:image" content="http://static.zybuluo.com/H4l0/0f2tiuo0j1kt1zry0d838ccv/image.png">
<meta property="og:image" content="http://static.zybuluo.com/H4l0/8y2k9sno5o5ecr99i227trsk/image.png">
<meta property="og:image" content="http://static.zybuluo.com/H4l0/z3ed3r8hmfgfdrmwzi3krhw4/image.png">
<meta property="og:image" content="http://static.zybuluo.com/H4l0/8eo6jdu65n3t2ytiftrmtuiw/image.png">
<meta property="article:published_time" content="2020-03-22T13:16:26.000Z">
<meta property="article:modified_time" content="2020-03-22T13:17:17.792Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="article">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://static.zybuluo.com/H4l0/bmyrepdupfcuj9hhuer0ra0x/image.png">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    
<link rel="stylesheet" href="/css/uno.css">

    
<link rel="stylesheet" href="/css/highlight.css">

    
<link rel="stylesheet" href="/css/archive.css">

    
<link rel="stylesheet" href="/css/china-social-icon.css">


<meta name="generator" content="Hexo 4.2.0"></head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">H4lo&#39;s blog</a></h1>
        <hr class="panel-cover__divider" />

        
        <p class="panel-cover__description">
          IOT 安全研究爱好者
        </p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



<nav class="cover-navigation navigation--social">
  <ul class="navigation">

    
      <!-- Github -->
      <li class="navigation__item">
        <a href="https://github.com/H4lo" target="_blank" rel="noopener" title="Huno on GitHub">
          <i class='icon icon-social-github'></i>
          <span class="label">GitHub</span>
        </a>
      </li>
    

    <!-- China social icon -->
    <!--
    
      <li class="navigation__item">
        <a href="" title="">
          <i class='icon cs-icon-douban'></i>
          <span class="label">Douban</span>
        </a>
      </li>

      <li class="navigation__item">
        <a href="" title="">
          <i class='icon cs-icon-weibo'></i>
          <span class="label">Weibo</span>
        </a>
      </li>

    -->



  </ul>
</nav>



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">cve-2020-8597 pppd stackoverflow</h1>

    

    <div class="post-meta">
      <time datetime="2020-03-22" class="post-meta__date date">2020-03-22</time> 

      <span class="post-meta__tags tags">

          

          
             &#8226; 标签:
            <font class="tags">
              <a class="tags-link" href="/tags/article/" rel="tag">article</a>
            </font>
          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 3月6号，国外安全研究员 Ilja Van Sprundel(IOActive) 发现了 pppd 组件的 EAP 协议中一个存在了 17 年的严重的栈溢出漏洞，导致所以使用 pppd 组件的系统都受影响，包括 Ubuntu、Debian、Fedora 等，有潜在的远程代码执行的风险，CVSS 评分为 9.8。</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ol>
<li>EAP 协议概念：</li>
</ol>
<pre><code>&gt; EAP协议是使用可扩展的身份验证协议的简称，全称Extensible Authentication Protocol。是一系列验证方式的集合，设计理念是满足任何链路层的身份验证需求，支持多种链路层认证方式。

因为 EAP 协议主要用于认证，因此这个漏洞影响了众多协议，如 pppoe、pptp 等。</code></pre><ol start="2">
<li>EAP 协议帧格式</li>
</ol>
<table>
<thead>
<tr>
<th>字段</th>
<th>占用字节数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Code</td>
<td>1个字节</td>
<td>表示EAP帧四种类型：1．Request；2．Response    3．Success；4．Failure</td>
</tr>
<tr>
<td>Identifier</td>
<td>1个字节</td>
<td>用于匹配Request和Response。Identifier的值和系统端口一起单独标识一个认证过程</td>
</tr>
<tr>
<td>Length</td>
<td>2个字节</td>
<td>表示EAP帧的总长度</td>
</tr>
<tr>
<td>Data</td>
<td>0或更多字节</td>
<td>表示EAP数据</td>
</tr>
</tbody></table>
<ul>
<li>code 用于标识 eap 协议为请求或者响应包，或者认证成功或者认证失败</li>
<li>length 字段用于表示 eap 帧 的长度，漏洞产生的原因就是因为对这个字段处理不当造成的。</li>
</ul>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>查看 github 上的 commit，发现 <code>eap.c</code> 文件中， 1420 行和 1846 行处的长度处理不当导致的一处栈溢出：</p>
<p><img src="http://static.zybuluo.com/H4l0/bmyrepdupfcuj9hhuer0ra0x/image.png" alt="image.png-157.2kB"></p>
<p>这两段代码分别位于 <code>eap_request()</code> 和 <code>eap_response()</code> 函数中，且都位于 <code>EAPT_MD5CHAP</code> 分支，很明显这两个是用来处理 EAP 协议的数据包请求和响应的函数。</p>
<ul>
<li>BCOPY 函数的定义：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define BCOPY(s, d, l)		memcpy(d, s, l) &#x2F;&#x2F;memcpy 函数的封装</span><br></pre></td></tr></table></figure>

<p>也就是第一个参数的指针指向的内存区域的字符，复制到第二个参数的内存空间中。因为第二个参数（rhostname）位于函数的栈上，导致复制完数据之后导致栈溢出，且可控制返回地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char rhostname[256];</span><br></pre></td></tr></table></figure>

<p>接着分析一下触发的条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if (vallen &lt; 8 || vallen &gt; len) &#123;</span><br><span class="line">			error(&quot;EAP: MD5-Challenge with bad length %d (8..%d)&quot;,vallen, len);</span><br><span class="line">            ...</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;* Not so likely to happen. *&#x2F;</span><br><span class="line">		if (vallen &gt;&#x3D; len + sizeof (rhostname)) &#123;</span><br><span class="line">			...</span><br><span class="line">			BCOPY(inp + vallen, rhostname, sizeof (rhostname) - 1);</span><br><span class="line">			rhostname[sizeof (rhostname) - 1] &#x3D; &#39;\0&#39;;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			BCOPY(inp + vallen, rhostname, len - vallen);</span><br><span class="line">			rhostname[len - vallen] &#x3D; &#39;\0&#39;;</span><br><span class="line">		&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>vallen 表示的是 <code>MD5CHAP</code> 的长度字段，为一个常量。</li>
</ul>
<p>如果要执行下面的代码段，必定要满足 <code>vallen &lt;= len</code>，所以这里必定会进入 else 的分支，只要 eap 数据包的长度 len 足够大，且 len - vallen 的长度大于 <code>rhostname</code> （/etc/hostname 中的内容）字符串的话，就会产生栈溢出。</p>
<p>因为请求和响应两个函数都存在栈溢出，因此在 client 端和 server 端均存在漏洞，在 server 端溢出就能够控制函数的返回地址，导致潜在的远程代码执行漏洞。</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>因为受影响的协议包括了 ppp、pppoe（Point-to-Point Protocol Over Ethernet），这里就直接拿 pppd 这个二进制程序来进行漏洞复现。</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>因为搭建 ppp 服务或者 pppoe 服务的话通常需要硬件环境，这里采取一种不依靠硬件的方法，即搭建两个虚拟机，用虚拟串口连接的方式进行通信（就像是对端的实体端到端连接）。</p>
<p>具体步骤如下：</p>
<ol>
<li>使用 virtual box 运行两台 ubuntu 虚拟机，一台搭建好了之后可以直接复制到另一台。<br> <img src="http://static.zybuluo.com/H4l0/j5xh9tkn0zkrr51dt9kwmnvk/image.png" alt="image.png-211.2kB"></li>
<li>将作为 server 虚拟机的 “设置 -&gt; 端口” 选项下，勾选启用串口，选择 COM1 （在 linux 下 COM1 可以看作是 /dev/ttyS0 设备）<br> <img src="http://static.zybuluo.com/H4l0/ff53jxokc4sf5l117fwrexx6/image.png" alt="image.png-172kB"></li>
<li>client 端的虚拟机也是同样的设置方法，但是<strong>需要注意的是，这里一定要勾选上 “连接至现有的通道或者套接字”！！</strong>，不勾选上的话虚拟机的串口是无法通信的。<br> <img src="http://static.zybuluo.com/H4l0/hjtax41lrm7zi09rg6rqo3ij/image.png" alt="image.png-176.2kB"></li>
<li>先将 server 端的虚拟机启动，之后再启动 client 端虚拟机。注意顺序，否则会报错。</li>
</ol>
<h4 id="测试联通性"><a href="#测试联通性" class="headerlink" title="测试联通性"></a>测试联通性</h4><p>测试串口的联通性，即一端将数据输入到 /dev/ttyS0 设备中；一端进行读取。</p>
<p><img src="http://static.zybuluo.com/H4l0/aswyzqnylf9oj341kkjs4i4h/image.png" alt="image.png-595.4kB"></p>
<p>发现这里的串口是通的，可以互相访问。</p>
<h4 id="编译-pppd-组件"><a href="#编译-pppd-组件" class="headerlink" title="编译 pppd 组件"></a>编译 pppd 组件</h4><p>从 github 上 clone 代码到本地（server 端和 client 端都需要），并编译、安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;paulusmack&#x2F;ppp.git</span><br><span class="line">cd ppp&#x2F;</span><br><span class="line">git checkout ppp-2.4.8          &#x2F;&#x2F; 切换到存在漏洞的分支</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make -j8</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>查看 pppd 的版本：</p>
<p><img src="http://static.zybuluo.com/H4l0/pgbm690ie2lq6sgerpi6x65y/image.png" alt="image.png-71.5kB"></p>
<h4 id="测试-pppd-通信"><a href="#测试-pppd-通信" class="headerlink" title="测试 pppd 通信"></a>测试 pppd 通信</h4><p>在 server 端运行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pppd &#x2F;dev&#x2F;ttyS0 9600 noauth local lock defaultroute debug nodetach 172.16.1.1:172.16.1.2 ms-dns 8.8.8.8</span><br></pre></td></tr></table></figure>
<ul>
<li>参数的介绍：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;dev&#x2F;ttyS0      &#x2F;&#x2F; 连接到的串口</span><br><span class="line">9600            &#x2F;&#x2F; 波特率</span><br><span class="line">noauth          &#x2F;&#x2F; 无密码认证</span><br><span class="line">local           &#x2F;&#x2F; 不要使用数据机控制线路</span><br><span class="line">lock            &#x2F;&#x2F; 在串口上锁定并使用互斥存取</span><br><span class="line">defaultroute    &#x2F;&#x2F; 采用默认路由</span><br><span class="line">debug           &#x2F;&#x2F; 显示连接过程中的封包内容</span><br><span class="line">nodetach        &#x2F;&#x2F; 不脱离终端</span><br></pre></td></tr></table></figure>

<p>运行命令之后，会将生成的 ppp0 端口绑定到 /dev/ttyS0 串口，这样 client 端可以通过访问 /dev/ttyS0 串口来访问 ppp 服务。</p>
<p><img src="http://static.zybuluo.com/H4l0/wu326u3885dromi3lyrmeym1/image.png" alt="image.png-274.9kB"></p>
<p>然后在 client 端运行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pppd noauth local lock defaultroute debug nodetach &#x2F;dev&#x2F;ttyS0 9600</span><br></pre></td></tr></table></figure>

<p>当获取到 IP 地址之后，就相当于客户端和服务端的端到端连接成功了，接着就可以测试漏洞点。</p>
<p><img src="http://static.zybuluo.com/H4l0/0f2tiuo0j1kt1zry0d838ccv/image.png" alt="image.png-2150.2kB"></p>
<h3 id="触发栈溢出漏洞"><a href="#触发栈溢出漏洞" class="headerlink" title="触发栈溢出漏洞"></a>触发栈溢出漏洞</h3><p>接着我们来测试 EAP 协议的栈溢出漏洞，所以这里前提就是需要服务端开启 eap 认证。</p>
<p>先在服务端运行命令，开启 eap 认证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pppd &#x2F;dev&#x2F;ttyS0 9600 auth local lock defaultroute debug nodetach 172.16.1.1:172.16.1.2 ms-dns 8.8.8.8 require-eap</span><br></pre></td></tr></table></figure>

<p>为了方便复现，在客户端的 eap.c 源代码 <code>eap_request()</code> 的函数中，在 <code>EAPT_MD5CHAP</code> 分支下，手动 patch 代码，加入发送到服务端的 payload：</p>
<p><img src="http://static.zybuluo.com/H4l0/8y2k9sno5o5ecr99i227trsk/image.png" alt="image.png-441.1kB"></p>
<p>重新编译客户端的 pppd 程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make -j8</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>在客户端运行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pppd noauth local lock defaultroute debug nodetach &#x2F;dev&#x2F;ttyS0 9600 user test password test</span><br></pre></td></tr></table></figure>

<p>运行起来之后很快会发现服务端的进程崩溃：</p>
<p><img src="http://static.zybuluo.com/H4l0/z3ed3r8hmfgfdrmwzi3krhw4/image.png" alt="image.png-2257.7kB"></p>
<h4 id="程序保护机制"><a href="#程序保护机制" class="headerlink" title="程序保护机制"></a>程序保护机制</h4><p>使用 checksec 命令查看程序保护机制，发现这里开启了 canary 保护，无 pie 保护，所以这里只需要绕过 canary 机制即可。</p>
<p><img src="http://static.zybuluo.com/H4l0/8eo6jdu65n3t2ytiftrmtuiw/image.png" alt="image.png-55.2kB"></p>
<h3 id="漏洞补丁"><a href="#漏洞补丁" class="headerlink" title="漏洞补丁"></a>漏洞补丁</h3><p>将判断改成 <code>len - vallen &gt;= sizeof (rhostname)</code>，当包的长度大于 <code>sizeof (rhostname)</code> 时，就会进入 if 判断，最多只会复制 <code>sizeof (rhostname)</code> 大小的数据，防止了栈溢出漏洞的发生。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">-		if (vallen &gt;&#x3D; len + sizeof (rhostname)) &#123;</span><br><span class="line">+		if (len - vallen &gt;&#x3D; sizeof (rhostname)) &#123;</span><br><span class="line">			dbglog(&quot;EAP: trimming really long peer name down&quot;);</span><br><span class="line">			BCOPY(inp + vallen, rhostname, sizeof (rhostname) - 1);</span><br><span class="line">			rhostname[sizeof (rhostname) - 1] &#x3D; &#39;\0&#39;;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			BCOPY(inp + vallen, rhostname, len - vallen);</span><br><span class="line">			rhostname[len - vallen] &#x3D; &#39;\0&#39;;</span><br><span class="line">		&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>


<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.kb.cert.org/vuls/id/782301/" target="_blank" rel="noopener">https://www.kb.cert.org/vuls/id/782301/</a><br><a href="https://github.com/paulusmack/ppp" target="_blank" rel="noopener">https://github.com/paulusmack/ppp</a><br><a href="https://github.com/marcinguy/CVE-2020-8597" target="_blank" rel="noopener">https://github.com/marcinguy/CVE-2020-8597</a><br><a href="https://gist.github.com/nstarke/551433bcc72ff95588e168a0bb666124" target="_blank" rel="noopener">https://gist.github.com/nstarke/551433bcc72ff95588e168a0bb666124</a></p>

  </section>

  <section class="post-comments">

    <!-- 将评论系统（例如Disqus、多说、友言、畅言等）提供的代码片段粘贴在这里 -->
    
</section>


</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno" target="_blank" rel="noopener">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/jquery.min.js"></script>
    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
